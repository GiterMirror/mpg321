From: Nanakos Chrysostomos <nanakos@wired-net.gr>
Subject: Added AudioScrobbler support and recursive directory reading.

--- mpg321-0.2.11.orig/options.c
+++ mpg321-0.2.11/options.c
@@ -1,7 +1,7 @@
 /*
     mpg321 - a fully free clone of mpg123.
     options.c: Copyright (C) 2001, 2002 Joe Drew
-    
+    	       Copyright (C) 2006, 2007, 2008, 2009, 2010 Nanakos Chrysostomos
     Originally based heavily upon:
     plaympeg - Sample MPEG player using the SMPEG library
     Copyright (C) 1999 Loki Entertainment Software
@@ -108,6 +108,8 @@ void parse_options(int argc, char *argv[
         { "remote", 0, 0, 'R' },
         { "set_xterm", 0, 0, 'x' },
         { "stereo", 0, 0, 'T' },
+        { "scrobbler", 0, 0, 'S' },
+        { "recursive", 0, 0, 'B' },
             
         /* takes parameters */
         { "frames", 1, 0, 'n' },
@@ -127,7 +129,7 @@ void parse_options(int argc, char *argv[
 
     while ((c = getopt_long(argc, argv, 
                                 "OPLTNEI824cy01mCd:h:f:b:r:G:" /* unimplemented */
-                                "A:D:vqtsVHzZRxo:n:@:k:w:a:g:l:p:u:U:",     /* implemented */
+                                "A:D:SBvqtsVHzZRxo:n:@:k:w:a:g:l:p:u:U:",     /* implemented */
                         long_options, &option_index)) != -1)
     {            
         switch(c)
@@ -172,6 +174,7 @@ void parse_options(int argc, char *argv[
 
             case 'v':
                 options.opt |= MPG321_VERBOSE_PLAY;
+		scrobbler_set_verbose(1);
                 setvbuf(stdout, NULL, _IONBF, 0);
                 break;
             
@@ -223,6 +226,14 @@ void parse_options(int argc, char *argv[
             case 's':
                 options.opt |= MPG321_USE_STDOUT;
                 break;
+
+	    case 'S':
+		options.opt |= MPG321_USE_SCROBBLER;
+		break;
+
+	    case 'B':
+		options.opt |= MPG321_RECURSIVE_DIR;
+		break;
                 
             case 'o':
                 if (strcmp(optarg, "alsa") == 0)
--- /dev/null
+++ mpg321-0.2.11/scrobbler.c
@@ -0,0 +1,112 @@
+/*
+    mpg321 - a fully free clone of mpg123.
+    scrobbler.c: Copyright (C) 2005-2006 Peter Pentchev
+    		 Copyright (C) 2010 Nanakos Chrysostomos
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <unistd.h>
+#include <sys/mman.h>
+#include <stdio.h>
+#include <limits.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "mpg321.h"
+
+#define SCROBBLER_PLUGIN_NAME   "321"
+#define SCROBBLER_PLUGIN_VER    "0.1"
+
+#define SCROBBLER_HELPER_PATH   "scrobbler-helper"
+#define SCROBBLER_CUTOFF        240
+#define SCROBBLER_LOW_CUTOFF    30
+
+char *scrobbler_args[6] = {
+    "", "", "", "", "", "",
+};
+int scrobbler_time = -1;
+static int scrobbler_track_length = -1;
+static int scrobbler_verbose = 0;
+
+void scrobbler_set_time(long seconds)
+{
+    if (seconds < SCROBBLER_LOW_CUTOFF)
+        scrobbler_time = -1;
+    else if (seconds < 2 * SCROBBLER_CUTOFF)
+        scrobbler_time = seconds / 2;
+    else
+        scrobbler_time = SCROBBLER_CUTOFF;
+    scrobbler_track_length = seconds;
+    if (scrobbler_verbose || MPG321_USE_SCROBBLER)
+        fprintf(stderr, "AudioScrobbler report at %d sec\n", scrobbler_time);
+}
+
+void scrobbler_report(void)
+{
+    char *args[] = {
+        SCROBBLER_HELPER_PATH,
+        "-P",
+        SCROBBLER_PLUGIN_NAME,
+        "-V",
+        SCROBBLER_PLUGIN_VER,
+        "--",
+        "", "", "", "", "", "",
+        "",
+        NULL
+    };
+#define SARGS_SIZE      (sizeof(args) / sizeof(args[0]))
+#define SARGS_POS       (SARGS_SIZE - (6 + 2))
+    char lengthbuf[20];
+
+    if (scrobbler_verbose) {
+        /*printf("Reporting to AudioScrobbler!\n");*/
+        args[1] = "-vP";
+    }
+    switch(fork()) {
+        case -1:
+            /* Error */
+            mpg321_error("forking for the scrobbler helper");
+            break;
+            
+        case 0:
+            /* Child: execute the scrobbler plug-in */
+            /* Do not close the AO fd*/
+            
+            /* Merge the ID3 info with the scrobbler helper execv() args */
+	    memcpy(args + SARGS_POS, scrobbler_args,
+                sizeof(scrobbler_args));
+            snprintf(lengthbuf, sizeof(lengthbuf),
+                "%d", scrobbler_track_length);
+            args[SARGS_SIZE - 2] = lengthbuf;
+            execvp(args[0], args);
+            mpg321_error("scrobbler helper " SCROBBLER_HELPER_PATH);
+            exit(1);
+            
+        default:
+            /* Parent: nothing to do */
+	    /* Continue playing the mp3 file or stream */
+            break;
+    }
+}
+
+void scrobbler_set_verbose(int v)
+{
+
+    scrobbler_verbose = v;
+}
--- mpg321-0.2.11.orig/mad.c
+++ mpg321-0.2.11/mad.c
@@ -230,6 +230,12 @@ enum mad_flow read_header(void *data, st
 
     mad_timer_add(&current_time, header->duration);
 
+    if(options.opt & MPG321_USE_SCROBBLER && scrobbler_time > 0 && scrobbler_time < current_time.seconds)
+    {
+	    scrobbler_time = -1;
+	    scrobbler_report();
+    }
+
     if(options.opt & (MPG321_VERBOSE_PLAY | MPG321_REMOTE_PLAY))
     {
         mad_timer_string(current_time, long_currenttime_str, "%.2u:%.2u.%.2u", MAD_UNITS_MINUTES,
@@ -307,7 +313,7 @@ enum mad_flow read_header(void *data, st
     {
         if (!options.skip_printing_frames 
             || (options.skip_printing_frames && !(current_frame % options.skip_printing_frames)))
-            fprintf(stderr, "Frame# %5lu [%5lu], Time: %s [%s], \r", current_frame, 
+			fprintf(stdout, "Frame# %5lu [%5lu], Time: %s [%s], \r", current_frame, 
                     playbuf->num_frames > 0 ? playbuf->num_frames - current_frame : 0, long_currenttime_str, long_remaintime_str);
     }
     
--- mpg321-0.2.11.orig/playlist.c
+++ mpg321-0.2.11/playlist.c
@@ -1,6 +1,7 @@
 /*
     mpg321 - a fully free clone of mpg123.
     Copyright (C) 2001 Joe Drew
+    Copyright (C) 2010 Nanakos Chrysostomos, Giuseppe Scrivano <gscrivano@gnu.org>
     
     Originally based heavily upon:
     plaympeg - Sample MPEG player using the SMPEG library
@@ -40,7 +41,9 @@
 #include <ctype.h>
 #include <errno.h>
 #include <libgen.h>
-
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
 #include "mpg321.h"
 
 playlist * new_playlist()
@@ -155,18 +158,57 @@ char * get_next_file(playlist *pl, buffe
     }
 }
 
-void add_cmdline_files(playlist *pl, char *argv[])
+void add_path(playlist *pl, char *path)
 {
-    int i;
-    for (i = optind; argv[i]; ++i )
+    struct stat sb;
+
+    if(lstat(path,&sb))
+	    return;
+    if(S_ISREG(sb.st_mode))
     {
         if (pl->numfiles == pl->files_size)
             resize_playlist(pl);
 
-        pl->files[(pl->numfiles)++] = strdup(argv[i]);
+        pl->files[(pl->numfiles)++] = path;
+    } else {
+	    DIR *dir = opendir(path);
+	    struct dirent *entry;
+	    if(dir == NULL)
+		    return;
+
+	    while((entry = readdir(dir)))
+	    {
+		    if(entry->d_name[0] != '.')
+		    {
+			    char *new_path = malloc(strlen(path)+strlen(entry->d_name)+2);
+			    sprintf(new_path, "%s/%s", path, entry->d_name);
+			    add_path(pl, new_path);
+		    }
+	    }
+	    closedir(dir);
+	    free(path);
     }
 }
 
+void add_cmdline_files_recursive_dir(playlist *pl, char *argv[])
+{
+	int i;
+	for(i= optind; argv[i]; ++i)
+		add_path(pl, strdup(argv[i]));
+}
+
+void add_cmdline_files(playlist *pl, char *argv[])
+{
+
+	int i;
+	for (i = optind; argv[i]; ++i )
+	{
+		if (pl->numfiles == pl->files_size)
+			resize_playlist(pl);
+		pl->files[(pl->numfiles)++] = strdup(argv[i]);
+	}
+}
+
 void play_remote_file(playlist *pl, char *file)
 {
     strncpy(pl->remote_file, file, PATH_MAX);
--- mpg321-0.2.11.orig/mpg321.h
+++ mpg321-0.2.11/mpg321.h
@@ -1,6 +1,7 @@
 /*
     mpg321 - a fully free clone of mpg123.
     Copyright (C) 2001 Joe Drew
+    Copyright (C) 2006, 2007, 2008, 2009, 2010 Nanakos Chrysostomos
     
     Originally based heavily upon:
     plaympeg - Sample MPEG player using the SMPEG library
@@ -38,8 +39,8 @@
 #include <ao/ao.h>
 #include <mad.h>
 
-#define FAKEVERSION "0.2.11-3"
-#define VERSIONDATE "2009/06/16"
+#define FAKEVERSION "0.2.11-4"
+#define VERSIONDATE "2010/05/24"
 
 #ifndef PATH_MAX
 #define PATH_MAX	4096
@@ -116,6 +117,8 @@ extern int file_change;
 int loop_remaining;
 
 extern int status;
+extern int scrobbler_time;
+extern char *scrobbler_args[6];
 
 enum
 {
@@ -145,7 +148,9 @@ enum
     MPG321_USE_USERDEF   = 0x00004000,
     MPG321_USE_ALSA09    = 0x00008000,
     
-    MPG321_FORCE_STEREO  = 0x00010000
+    MPG321_FORCE_STEREO  = 0x00010000,
+    MPG321_USE_SCROBBLER  = 0x00020000,
+    MPG321_RECURSIVE_DIR  = 0x00040000,
 };
 
 #define DEFAULT_PLAYLIST_SIZE 1024
@@ -156,6 +161,7 @@ playlist * new_playlist();
 void resize_playlist(playlist *pl);
 char * get_next_file(playlist *pl, buffer *buf);
 void add_cmdline_files(playlist *pl, char *argv[]);
+void add_cmdline_files_recursive_dir(playlist *pl, char *argv[]);
 void add_file(playlist *pl, char *file);
 void load_playlist(playlist *pl, char *filename);
 void set_random_play(playlist *pl);
@@ -178,6 +184,8 @@ enum mad_flow read_header(void *data, st
 enum mad_flow output(void *data, struct mad_header const *header, struct mad_pcm *pcm);
 int calc_length(char *file, buffer*buf );
 
+static enum mad_flow handle_error(void *data, struct mad_stream *stream, struct mad_frame *frame);
+
 enum mad_flow move(buffer *buf, signed long frames);
 void seek(buffer *buf, signed long frame);
 void pause_play(buffer *buf, playlist *pl);
@@ -210,4 +218,11 @@ char *ctty_path();
 void get_term_title(char *title);
 int tty_read(char *output,size_t size);
 
+/* AudioScrobbler functions */
+void scrobbler_report(void);
+void scrobbler_set_time(long);
+void scrobbler_set_verbose(int);
+
+RETSIGTYPE handle_sigchld(int sig);
+
 #endif /* _MPG321_H_ */
--- mpg321-0.2.11.orig/mpg321.c
+++ mpg321-0.2.11/mpg321.c
@@ -1,6 +1,7 @@
 /*
     mpg321 - a fully free clone of mpg123.
     Copyright (C) 2001 Joe Drew
+    Copyright (C) 2006-2010 Nanakos Chrysostomos
     
     Originally based heavily upon:
     plaympeg - Sample MPEG player using the SMPEG library
@@ -49,6 +50,7 @@
 
 #include "getopt.h" /* GNU getopt is needed, so I included it */
 #include "mpg321.h"
+#include <sys/wait.h>
 
 #include <id3tag.h>
 
@@ -78,6 +80,52 @@ int file_change = 0;
 
 char *id3_get_tag (struct id3_tag const *tag, char const *what, unsigned int maxlen);
 
+/* Ignore child processes from the AudioScrobbler helper */
+RETSIGTYPE handle_sigchld(int sig)
+{
+	int stat;
+	while(waitpid(-1, &stat, WNOHANG) > 0)
+		;
+}
+
+static struct {
+	int index;
+	const char *id;
+	const char *name;
+} const info_id3[] = {
+	{ 0 ,	ID3_FRAME_TITLE,	"Title	: "	},
+	{ 1 ,	ID3_FRAME_ARTIST,	" Artist : "	},
+	{ 2 ,	ID3_FRAME_ALBUM,	"Album	: "	},
+	{ 3 ,	ID3_FRAME_YEAR,		" Year	 : "	},
+	{ 4 ,	ID3_FRAME_COMMENT,	"Comment : "	},
+	{ 5 ,	ID3_FRAME_GENRE,	" Genre : "	}
+};
+
+/* Parse an ID3 tag into TITLE, ARTIST, ALBUM, YEAR, COMMENT, GENRE
+ * and return true if at least one of those is present.
+ */
+
+static int parse_id3( char *names[], const struct id3_tag *tag)
+{
+	int found, i;
+
+	found = 0;
+	/* Get ID3 tag if available, 30 chars except 4 for year */
+	for(i=0; i<=5; i++)
+	{
+		names[i] = NULL;
+		names[i] = id3_get_tag(tag, info_id3[i].id, (i==3) ? 4 : 30);
+		if( names[i] != NULL && names[i][0] != '\0' )
+			found = 1;
+	}
+
+	return (found);
+}
+
+
+
+
+
 void mpg123_boilerplate()
 {
     fprintf(stderr,"High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2, and 3.\n"
@@ -119,6 +167,8 @@ void usage(char *argv0)
         "   --loop N or -l N         Play files N times. 0 means until\n"
         "                            interrupted\n"
         "   -R                       Use remote control interface\n"
+        "   -B                       Read recursively the given directories\n"
+        "   -S                       Report mp3 file to AudioScrobbler\n"
         "   -x                       Set xterm title setting\n"
         "   -p hostname:port         Use proxy server\n"
         "   -u username:password     Use proxy server basic authentication\n"
@@ -169,36 +219,13 @@ RETSIGTYPE handle_signals(int sig)
 static int show_id3(struct id3_tag const *tag)
 {
     unsigned int i;
-    int print = 0;
     char emptystring[31];
     char *names[6];
-    struct {
-        int index;
-        char const *id;
-        char const *name;
-    } const info[] = {
-        { 0,    ID3_FRAME_TITLE,  "Title  : "   },
-        { 1,    ID3_FRAME_ARTIST, "  Artist: "  },
-        { 2,    ID3_FRAME_ALBUM,  "Album  : "   },
-        { 3,    ID3_FRAME_YEAR,   "  Year  : "  },
-        { 4,    ID3_FRAME_COMMENT,"Comment: "   },
-        { 5,    ID3_FRAME_GENRE,  "  Genre : "  }
-    };
 
     memset (emptystring, ' ', 30);
     emptystring[30] = '\0';
-    /*  Get ID3 tag if available, 30 chars except 4 for year  */
-    for (i=0; i<=5; i++)    {
-        names[i] = NULL;
-        names[i] = id3_get_tag(tag, info[i].id, (i==3) ? 4 : 30);
-    }
-    for (i=0; i<=5; i++)    {
-        if (names[i])   {
-            print = 1;
-            break;
-        }
-    }
-    if (!print) {
+    
+    if (!parse_id3(names, tag)) {
         return 0;
     }
 
@@ -226,7 +253,7 @@ static int show_id3(struct id3_tag const
     {
         /* Emulate mpg123 original behaviour  */
         for (i=0; i<=5; i++)    {
-            fprintf (stderr, "%s", info[i].name);
+            fprintf (stderr, "%s", info_id3[i].name);
             if (!names[i])  {
                 fprintf (stderr, emptystring);
             }   else    {
@@ -240,6 +267,28 @@ static int show_id3(struct id3_tag const
     return 1;
 }
 
+static int get_id3_info( const char *fname, struct id3_file **id3struct, struct id3_tag **id3tag)
+{
+	struct id3_file *s;
+	struct id3_tag *t;
+
+	s = id3_file_open(fname, ID3_FILE_MODE_READONLY);
+	if( s == NULL )
+		return (0);
+
+	t = id3_file_tag(s);
+	if(t == NULL)
+	{
+		id3_file_close(s);
+		return (0);
+	}
+
+	*id3struct = s;
+	*id3tag = t;
+	return (1);
+}
+
+
 int main(int argc, char *argv[])
 {
     int fd = 0;
@@ -280,8 +329,11 @@ int main(int argc, char *argv[])
 
     if (playlist_file)
         load_playlist(pl, playlist_file);
-    
-    add_cmdline_files(pl, argv);
+
+    if(options.opt & MPG321_RECURSIVE_DIR)
+	    add_cmdline_files_recursive_dir(pl, argv);
+    else
+	    add_cmdline_files(pl, argv);
 
     if (shuffle_play)
         shuffle_files(pl);
@@ -335,32 +387,54 @@ int main(int argc, char *argv[])
         
         mad_timer_reset(&current_time);
 
+	id3struct = NULL;
+
         if (!(options.opt & MPG321_QUIET_PLAY) && file_change)
         {
-            id3struct = id3_file_open (currentfile, ID3_FILE_MODE_READONLY);
+           /* id3struct = id3_file_open (currentfile, ID3_FILE_MODE_READONLY);*/
 
-            if (id3struct)
-            {
-                id3tag = id3_file_tag (id3struct);
-            
-                if (id3tag)
-                {
-                    show_id3 (id3tag);
-                }
+            if (id3struct == NULL)
+		    get_id3_info(currentfile, &id3struct, &id3tag);
+	    if(id3tag)
+		    show_id3(id3tag);
+	}
 
-                id3_file_close (id3struct);
-            }
-        }
+	scrobbler_time = -1;
+	if(options.opt & MPG321_USE_SCROBBLER)
+	{
+		if(id3struct == NULL)
+			get_id3_info(currentfile,&id3struct,&id3tag);
+                
+	    if (id3tag)
+	    {
+		    char emptystring[31], emptyyear[5] = "    ";
+		    int i;
+
+		    if(parse_id3(scrobbler_args, id3tag))
+		    {
+			    memset(emptystring, ' ', 30);
+			    emptystring[30] = '\0';
+	    		    if((options.opt & MPG321_VERBOSE_PLAY) && (options.opt & MPG321_USE_SCROBBLER))
+			    {
+				    fprintf(stderr, "\nPreparing for the AudioScrobbler:\n");
+				    for(i = 0; i < 6; i++)
+				    {
+					    if(scrobbler_args[i] == NULL)
+						    scrobbler_args[i] =
+							    ( i == 3 ? emptyyear: emptystring);
+					    fprintf(stderr, "- %s\n", scrobbler_args[i]);
+				    }
+			    }
+		    }
+	    }
+	}
+      
 
         if (options.opt & MPG321_REMOTE_PLAY && file_change)
         {
-            id3struct = id3_file_open (currentfile, ID3_FILE_MODE_READONLY);
-
-            if (id3struct)
-            {
-                id3tag = id3_file_tag (id3struct);
-            
-                if (id3tag)
+		if(id3struct == NULL)
+			get_id3_info(currentfile, &id3struct, &id3tag);
+		if(id3tag)
                 {
                     if (!show_id3(id3tag))
                     {
@@ -381,14 +455,6 @@ int main(int argc, char *argv[])
                     }
                 }
                 
-                else
-                {
-                    fprintf(stderr, "Allocation error");
-                    exit(1);
-                }
-
-                id3_file_close (id3struct);
-            }
             
             else
             {
@@ -406,6 +472,9 @@ int main(int argc, char *argv[])
             }
         }
 
+	if(id3struct != NULL)
+		id3_file_close(id3struct);
+
         /* Create the MPEG stream */
         /* Check if source is on the network */
         if((fd = raw_open(currentfile)) != 0 || (fd = http_open(currentfile)) != 0
@@ -416,7 +485,7 @@ int main(int argc, char *argv[])
             playbuf.length = BUF_SIZE;
             
             mad_decoder_init(&decoder, &playbuf, read_from_fd, read_header, /*filter*/0,
-                            output, /*error*/0, /* message */ 0);
+                            output, handle_error, /* message */ 0);
         }
 
         /* Check if we are to use stdin for input */
@@ -427,7 +496,7 @@ int main(int argc, char *argv[])
             playbuf.length = BUF_SIZE;
 
             mad_decoder_init(&decoder, &playbuf, read_from_fd, read_header, /*filter*/0,
-                            output, /*error*/0, /* message */ 0);
+                            output, handle_error, /* message */ 0);
         }
             
         /* currentfile is a local file (presumably.) mmap() it */
@@ -438,8 +507,9 @@ int main(int argc, char *argv[])
             if((fd = open(currentfile, O_RDONLY)) == -1)
             {
                 mpg321_error(currentfile);
-
+		exit(1);
                 /* mpg123 stops immediately if it can't open a file */
+		/* If sth goes wrong break!!!*/
                 break;
             }
             
@@ -456,6 +526,12 @@ int main(int argc, char *argv[])
             
             calc_length(currentfile, &playbuf);
 
+	    if((options.opt & MPG321_VERBOSE_PLAY) && (options.opt & MPG321_USE_SCROBBLER))
+		    fprintf(stderr, "Track duration: %ld seconds\n",playbuf.duration.seconds);
+
+	    if(options.opt & MPG321_USE_SCROBBLER)
+		    scrobbler_set_time(playbuf.duration.seconds);
+
             if ((options.maxframes != -1) && (options.maxframes <= playbuf.num_frames))
             { 
                 playbuf.max_frames = options.maxframes;
@@ -474,7 +550,7 @@ int main(int argc, char *argv[])
             playbuf.frames[0] = playbuf.buf;
             
             mad_decoder_init(&decoder, &playbuf, read_from_mmap, read_header, /*filter*/0,
-                            output, /*error*/0, /* message */ 0);
+                            output, handle_error, /* message */ 0);
         }
 
         if(!(options.opt & MPG321_QUIET_PLAY))/*zip it!!!*/
@@ -518,6 +594,7 @@ int main(int argc, char *argv[])
         }    
 
         signal(SIGINT, handle_signals);
+	signal(SIGCHLD, handle_sigchld);
         /*Give control back so that we can implement SIG's*/
 	if(set_xterm)
 	{
@@ -851,3 +928,34 @@ void get_term_title(char *title)
 
 	snprintf((char *)title,sizeof(buffer),"%s",buffer+3);
 }
+
+static enum mad_flow handle_error(void *data, struct mad_stream *stream, struct mad_frame *frame)
+{
+	signed long tagsize;
+
+	switch(stream->error)
+	{
+		case MAD_ERROR_BADDATAPTR:
+			return MAD_FLOW_CONTINUE;
+		case MAD_ERROR_LOSTSYNC:
+			tagsize = id3_tag_query(stream->this_frame,stream->bufend - stream->this_frame);
+			if(tagsize > 0)
+			{
+				mad_stream_skip(stream, tagsize);
+				return MAD_FLOW_CONTINUE;
+			}
+
+		default:
+			break;
+	}
+
+	if(stream->error == MAD_ERROR_BADCRC)
+	{
+		mad_frame_mute(frame);
+		return MAD_FLOW_IGNORE;
+	}
+
+	return MAD_FLOW_CONTINUE;
+}
+
+
